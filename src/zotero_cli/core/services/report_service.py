import json
import os
import re
import subprocess
import tempfile
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional

from zotero_cli.core.interfaces import ZoteroGateway
from zotero_cli.core.zotero_item import ZoteroItem


@dataclass
class PrismaReport:
    collection_name: str
    total_items: int = 0
    screened_items: int = 0
    accepted_items: int = 0
    rejected_items: int = 0
    rejections_by_code: Dict[str, int] = field(default_factory=dict)
    malformed_notes: List[str] = field(default_factory=list)


class ReportService:
    """
    Service for generating systematic review reports (PRISMA).
    Parses Standardized Decision Blocks (SDB) from Zotero notes.
    """

    def __init__(self, gateway: ZoteroGateway):
        self.gateway = gateway

    def generate_prisma_report(self, collection_name: str) -> Optional[PrismaReport]:
        col_id = self.gateway.get_collection_id_by_name(collection_name)
        if not col_id:
            return None

        report = PrismaReport(collection_name=collection_name)
        items = self.gateway.get_items_in_collection(col_id)

        for item in items:
            report.total_items += 1
            self._process_item_notes(item, report)

        return report

    def generate_mermaid_prisma(self, report: PrismaReport) -> str:
        """Generates Mermaid DSL for a PRISMA Flow Diagram."""
        mermaid = [
            "graph TD",
            f"  A[Identification: {report.total_items} items] --> B[Screening: {report.screened_items} items]",
            "  B --> C{Decision}",
            f"  C -- Included --> D[Accepted: {report.accepted_items}]",
            f"  C -- Excluded --> E[Rejected: {report.rejected_items}]",
        ]

        if report.rejections_by_code:
            for i, (code, count) in enumerate(report.rejections_by_code.items()):
                mermaid.append(f"  E --> E{i}[{code}: {count}]")

        return "\n".join(mermaid)

    def render_diagram(self, mermaid_code: str, output_path: str) -> bool:
        """Renders Mermaid code to an image file using global mmdc."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".mmd", delete=False) as tmp:
            tmp.write(mermaid_code)
            tmp_path = tmp.name

        try:
            cmd = ["mmdc", "-i", tmp_path, "-o", output_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error running mmdc: {result.stderr}")
                return False
            return True
        except Exception as e:
            print(f"Error rendering diagram: {e}")
            return False
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)

    def generate_screening_markdown(self, report: PrismaReport) -> str:
        """Generates a complete Markdown report for the screening phase."""
        percent_complete = (
            (report.screened_items / report.total_items * 100) if report.total_items > 0 else 0
        )

        md = [
            f"# Screening Report: {report.collection_name}",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## 1. Executive Summary",
            f"*   **Total Items in Collection:** {report.total_items}",
            f"*   **Items Screened:** {report.screened_items} ({percent_complete:.1f}%)",
            f"*   **Included (Accepted):** {report.accepted_items}",
            f"*   **Excluded (Rejected):** {report.rejected_items}",
            "",
            "## 2. Rejection Reasons",
            "| Reason Code | Count | Percentage |",
            "| :--- | :---: | :---: |",
        ]

        for code, count in sorted(report.rejections_by_code.items()):
            percent = (count / report.rejected_items * 100) if report.rejected_items > 0 else 0
            md.append(f"| {code} | {count} | {percent:.1f}% |")

        md.extend(
            [
                "",
                "## 3. PRISMA 2020 Flow Diagram",
                "```mermaid",
                self.generate_mermaid_prisma(report),
                "```",
                "",
                "---",
                "*Generated by zotero-cli Systematic Review Engine.*",
            ]
        )

        return "\n".join(md)

    def _process_item_notes(self, item: ZoteroItem, report: PrismaReport):
        children = self.gateway.get_item_children(item.key)

        for child in children:
            data_raw = child.get("data", child)
            if data_raw.get("itemType") == "note":
                note_content = data_raw.get("note", "")
                json_str = self._extract_json_from_note(note_content)
                if not json_str:
                    continue

                try:
                    data = json.loads(json_str)
                    if data.get("action") == "screening_decision" or "audit_version" in data:
                        decision = data.get("decision", "").lower()
                        if decision in ["accepted", "include"]:
                            report.accepted_items += 1
                        elif decision in ["rejected", "exclude"]:
                            report.rejected_items += 1
                            codes = data.get("reason_code", [])
                            if isinstance(codes, str):
                                codes = [codes]
                            elif not codes and "code" in data:
                                codes = [data["code"]]
                            for code in codes:
                                report.rejections_by_code[code] = (
                                    report.rejections_by_code.get(code, 0) + 1
                                )
                        report.screened_items += 1
                        break
                except json.JSONDecodeError:
                    report.malformed_notes.append(item.key)

    def _extract_json_from_note(self, content: str) -> Optional[str]:
        match = re.search(r"\{.*\}", content, re.DOTALL)
        if match:
            return match.group(0)
        return None
